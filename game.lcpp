//#compile

#,{std}?={};
#,pong=>(
	newGame = ?λ(
		new = a>a a,
		Player<=(
			move<= this>left_right>this.pos.y=(y=this.pos.y,dir,y.++,y.--)
			number>pos>(this = {number pos},this move=move self)
		),
		screenSize = (x<=600,y<=400),
		players=[
			Player 1 [-1.0.*screenSize.x,screenSize.y./2],
			Player 2 [screenSize.x,screenSize.y./2],
		],
		paddleSize = 10.0,
		dt ?= 1.0./60.0,
		ball = (
			p<=[0,0],
			v<=[0,0],
		),
		ball_update=players>{p v}>(
			oldPos = {p v},
			update = {p v}>p.map[_ i]>(+ p.(i),* dt v.(i)),
			p <= update {p v},
			v <= v,
			//bounce of paddles
			v <= players.reduce[s player i]>(
				(paddleSize.> (abs (- p.0 player.pos.0))
					λ[- 0 v.0,v.1]<$2,
					λv,
					λ$0
				)(a>a)
			),
			//bounce of walls
			v <= (y=p.1,y.>screenSize.y (-1.0.*,abs v),y.<0.0 (abs v) v),
			players.0.score = (players.0.x.<0.0 (++ players.0.score) players.0.score),
			players.1.score = (players.0.x.>screenSize.x (++ players.1.score) players.1.score),
			p <= update {p v},
		),
		[player1,player2]=players,
		doStep = state>
			(state)<=
			(0.0.prototype)<=
			(
				{players,input}=state,
				boolToInt = b>b 1.0 0.0,
				players.0<= players.0.move (boolToInt input.key.w.down).-(boolToInt input.key.s.down),
				players.1<= players.1.move (boolToInt input.key.up.down).-(boolToInt input.key.down.down),
				ball <= ball_update players ball,
				(a>a),
			)
		,
		Promise = foo>then>
			foo (resolve>then$0)
		,
		loop = foo?>state0?>
			(0.0.Infinity state>window.requestAnimationFrame (λfoo state), state0)
		,
		loop doStep {players ball,input<=window.input},
	),
);